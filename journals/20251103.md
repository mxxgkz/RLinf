# Download OpenVLA model
- `hf download gen-robot/openvla-7b-rlvla-warmup --local-dir ./pre_trained_model/openvla-7b-rlvla-warmup/`

# Download OpenVLAOFT model
- `hf download Haozhan72/Openvla-oft-SFT-libero10-traj1 --local-dir ./pre_trained_model/Openvla-oft-SFT-libero10-traj1/`

# Download pi0 SFT model
- `hf download RLinf/RLinf-Pi0-SFT-Long --local-dir ./pre_trained_model/RLinf-Pi0-SFT-Long`

# Download pi0 SFT for libero goal
- The following seems not working
```sh
# Option A: Login interactively
huggingface-cli login
# or
hf login

# Option B: Use a token (if you have one)
export HF_TOKEN="your_token_here"
hf download RLinf/RLinf-Pi0-SFT-Spatial-Object-Goal --local-dir ./pre_trained_model/RLinf-Pi0-SFT-Spatial-Object-Goal
```
- `git clone https://huggingface.co/RLinf/RLinf-Pi0-SFT-Spatial-Object-Goal`
- Need to start a new cpu job to download this


# Download maniskills_assets
- `git clone https://huggingface.co/datasets/RLinf/maniskill_assets`
    - This contains `carrot/more_carrot` that is needed in `maniskill_ppo_openvla`

# We can download maniskill asset using the following command, but it is too large
- `python -m mani_skill2.utils.download_asset all`

# In order to run `openpi` model, I need to rerun
- `bash requirements/install.sh openpi`
    - In `base` or `RLinf` env, I cannot run the cmd above, need to go to another env.
- Solve the `import openpi.shared.download` issue
- Install `libero`:
    - `pip install --ignore-installed --no-deps -e ../libero`

# See config tutorial `https://rlinf.readthedocs.io/en/latest/rst_source/tutorials/user/yaml.html`

# Problem of `maniskill_ppo_openvla_mini` hanging
- Seems like if I set actor, rollout, env any to just one gpu, it will have the following in the log. And it would hang.
```sh
[36m(EmbodiedFSDPActor pid=1699416)[0m /home/guo/RL/RLinf/.venv/lib/python3.11/site-packages/torch/distributed/fsdp/_init_utils.py:444: UserWarning: FSDP is switching to use `NO_SHARD` instead of ShardingStrategy.FULL_SHARD since the world size is 1.
```
- The issue is unclear, but setting above three to gpu>1 seems solve the issue.
- This also appears in libero. Lowering `num_group_envs` and setting `sharding_strategy="shard_grad_op"` seems to help.

# Use `sbatch`
- `--gres=gpu:h100:1` for h100

# Use `srun`
- Start a new job: 
    - `quest`: 
        - gpu: `srun -A p30309 -p gengpu --gres=gpu:2 --time=03:59:00 --mem=400G --pty /bin/bash`
        - cpu: `srun -A p30309 -p short --cpus-per-task=10 --mem=100G --time=03:59:00 --pty /bin/bash`
    - `magics`: `srun -p job_a100 --gres=gpu:2 --time=04:00:00 --mem=200G --pty /bin/bash`
- Run job on bg: `nohup ./your_script.sh > /dev/null 2>&1 &`
- Detailed: `sinfo -N -o "%N %P %T %C %G %O %E"`
- Summary: `sinfo -s`
- Cannot do `#SBATCH --gres=gpu:a100:${NGPU}`

# Observations
- It can take 20-30 minutes to run `ray::EnvWorker.init_worker`. It is normal. Observed in `libero_10_ppo_openpi`.
- I noticed some strange behavior on `qgpu3006`. When I run the job on that node, the nvidia-smi gives the following error, `GPU 00000000:42:00.0: Detected Critical Xid Error`. And one gpu has `100%` utilization, while the other has `0%`. And for some job that I can run on other nodes, it gets stuck on `qgpu3006`.


# Resuming Training from Checkpoints

If training gets interrupted, you can resume from the latest checkpoint instead of starting from scratch.

## How Checkpoints Work

- Checkpoints are automatically saved every `save_interval` steps (e.g., every 40 steps if `save_interval: 40`)
- Checkpoints are saved in: `{runner.logger.log_path}/{runner.logger.experiment_name}/checkpoints/global_step_{N}/`
- Each checkpoint contains:
  - Model weights (actor network)
  - Optimizer state (Adam parameters)
  - Global step counter

## Example: Resuming from `logs/20251103-06:10:02`

1. **Find the latest checkpoint:**
   ```bash
   # Check available checkpoints
   ls -la logs/20251103-06:10:02/test_openvla/checkpoints/
   
   # Or use the helper script:
   ./find_latest_checkpoint.sh logs/20251103-06:10:02/test_openvla/checkpoints
   ```

2. **Add `resume_dir` to your config YAML:**
   ```yaml
   runner:
     task_type: embodied
     logger:
       log_path: "logs/20251103-06:10:02"  # Your log directory
       experiment_name: "test_openvla"
     
     # Add this line to resume from checkpoint:
     resume_dir: "logs/20251103-06:10:02/test_openvla/checkpoints/global_step_40"
     
     max_epochs: 1000
     save_interval: 40
     # ... rest of config stays the same
   ```

3. **Run training exactly as before:**
   ```bash
   ./run_embodiment.sh maniskill_ppo_openvla
   ```

## What Gets Restored

- âœ… Model weights (actor network)
- âœ… Optimizer state (Adam parameters)  
- âœ… Global step counter (training continues from checkpoint step)
- âœ… Training resumes seamlessly â€” next checkpoint saves at step 80, 120, etc.

## Important Notes

- The checkpoint directory structure is: `checkpoints/global_step_{N}/actor/`
- Make sure the `resume_dir` path is correct relative to where you run the script
- All other config settings remain the same â€” only add `resume_dir`
- The code automatically handles checkpoint loading in `EmbodiedFSDPActor.init_worker()`

## Quick Reference

**Checkpoint location pattern:**
```
{log_path}/{experiment_name}/checkpoints/global_step_{step_number}/actor/
```

**Example paths:**
- Latest checkpoint: `logs/20251103-06:10:02/test_openvla/checkpoints/global_step_40`
- Next checkpoint: `logs/20251103-06:10:02/test_openvla/checkpoints/global_step_80`


# torch `weights_only` (for libero env)
- It involves changing the `libero` codebase. After solving this, the libero example seems to be running.
- `pip install torch==2.6.0 torchvision==0.21.0 torchaudio==2.5.0 torchdata==0.11.0`
- `pip install torch==2.5.0 torchvision==0.20.0 torchaudio==2.5.0 torchdata==0.8.0`
- code
```python
import torch, inspect, textwrap
import torch.serialization

source = inspect.getsource(torch.serialization.load)
print(textwrap.indent(source, "    "))
```
- `torch` 2.5
```python
def load(
    f: FILE_LIKE,
    map_location: MAP_LOCATION = None,
    pickle_module: Any = None,
    *,
    weights_only: Optional[bool] = None,
    mmap: Optional[bool] = None,
    **pickle_load_args: Any,
) -> Any:
    # Reference: https://github.com/pytorch/pytorch/issues/54354
    # The first line of this docstring overrides the one Sphinx generates for the
    # documentation. We need it so that Sphinx doesn't leak `pickle`s path from
    # the build environment (e.g. `<module 'pickle' from '/leaked/path').

    """load(f, map_location=None, pickle_module=pickle, *, weights_only=False, mmap=None, **pickle_load_args)

    Loads an object saved with :func:`torch.save` from a file.

    :func:`torch.load` uses Python's unpickling facilities but treats storages,
    which underlie tensors, specially. They are first deserialized on the
    CPU and are then moved to the device they were saved from. If this fails
    (e.g. because the run time system doesn't have certain devices), an exception
    is raised. However, storages can be dynamically remapped to an alternative
    set of devices using the :attr:`map_location` argument.

    If :attr:`map_location` is a callable, it will be called once for each serialized
    storage with two arguments: storage and location. The storage argument
    will be the initial deserialization of the storage, residing on the CPU.
    Each serialized storage has a location tag associated with it which
    identifies the device it was saved from, and this tag is the second
    argument passed to :attr:`map_location`. The builtin location tags are ``'cpu'``
    for CPU tensors and ``'cuda:device_id'`` (e.g. ``'cuda:2'``) for CUDA tensors.
    :attr:`map_location` should return either ``None`` or a storage. If
    :attr:`map_location` returns a storage, it will be used as the final deserialized
    object, already moved to the right device. Otherwise, :func:`torch.load` will
    fall back to the default behavior, as if :attr:`map_location` wasn't specified.

    If :attr:`map_location` is a :class:`torch.device` object or a string containing
    a device tag, it indicates the location where all tensors should be loaded.

    Otherwise, if :attr:`map_location` is a dict, it will be used to remap location tags
    appearing in the file (keys), to ones that specify where to put the
    storages (values).

    User extensions can register their own location tags and tagging and
    deserialization methods using :func:`torch.serialization.register_package`.

    Args:
        f: a file-like object (has to implement :meth:`read`, :meth:`readline`, :meth:`tell`, and :meth:`seek`),
            or a string or os.PathLike object containing a file name
        map_location: a function, :class:`torch.device`, string or a dict specifying how to remap storage
            locations
        pickle_module: module used for unpickling metadata and objects (has to
            match the :attr:`pickle_module` used to serialize file)
        weights_only: Indicates whether unpickler should be restricted to
            loading only tensors, primitive types, dictionaries
            and any types added via :func:`torch.serialization.add_safe_globals`.
        mmap: Indicates whether the file should be mmaped rather than loading all the storages into memory.
            Typically, tensor storages in the file will first be moved from disk to CPU memory, after which they
            are moved to the location that they were tagged with when saving, or specified by ``map_location``. This
            second step is a no-op if the final location is CPU. When the ``mmap`` flag is set, instead of copying the
            tensor storages from disk to CPU memory in the first step, ``f`` is mmaped.
        pickle_load_args: (Python 3 only) optional keyword arguments passed over to
            :func:`pickle_module.load` and :func:`pickle_module.Unpickler`, e.g.,
            :attr:`errors=...`.

    .. warning::
        :func:`torch.load()` unless `weights_only` parameter is set to `True`,
        uses ``pickle`` module implicitly, which is known to be insecure.
        It is possible to construct malicious pickle data which will execute arbitrary code
        during unpickling. Never load data that could have come from an untrusted
        source in an unsafe mode, or that could have been tampered with. **Only load data you trust**.

    .. note::
        When you call :func:`torch.load()` on a file which contains GPU tensors, those tensors
        will be loaded to GPU by default. You can call ``torch.load(.., map_location='cpu')``
        and then :meth:`load_state_dict` to avoid GPU RAM surge when loading a model checkpoint.

    .. note::
        By default, we decode byte strings as ``utf-8``.  This is to avoid a common error
        case ``UnicodeDecodeError: 'ascii' codec can't decode byte 0x...``
        when loading files saved by Python 2 in Python 3.  If this default
        is incorrect, you may use an extra :attr:`encoding` keyword argument to specify how
        these objects should be loaded, e.g., :attr:`encoding='latin1'` decodes them
        to strings using ``latin1`` encoding, and :attr:`encoding='bytes'` keeps them
        as byte arrays which can be decoded later with ``byte_array.decode(...)``.

    Example:
        >>> # xdoctest: +SKIP("undefined filepaths")
        >>> torch.load("tensors.pt", weights_only=True)
        # Load all tensors onto the CPU
        >>> torch.load("tensors.pt", map_location=torch.device("cpu"), weights_only=True)
        # Load all tensors onto the CPU, using a function
        >>> torch.load(
        ...     "tensors.pt", map_location=lambda storage, loc: storage, weights_only=True
        ... )
        # Load all tensors onto GPU 1
        >>> torch.load(
        ...     "tensors.pt",
        ...     map_location=lambda storage, loc: storage.cuda(1),
        ...     weights_only=True,
        ... )  # type: ignore[attr-defined]
        # Map tensors from GPU 1 to GPU 0
        >>> torch.load("tensors.pt", map_location={"cuda:1": "cuda:0"}, weights_only=True)
        # Load tensor from io.BytesIO object
        # Loading from a buffer setting weights_only=False, warning this can be unsafe
        >>> with open("tensor.pt", "rb") as f:
        ...     buffer = io.BytesIO(f.read())
        >>> torch.load(buffer, weights_only=False)
        # Load a module with 'ascii' encoding for unpickling
        # Loading from a module setting weights_only=False, warning this can be unsafe
        >>> torch.load("module.pt", encoding="ascii", weights_only=False)
    """
    torch._C._log_api_usage_once("torch.load")
    UNSAFE_MESSAGE = (
        "Re-running `torch.load` with `weights_only` set to `False` will likely succeed, "
        "but it can result in arbitrary code execution. Do it only if you got the file from a "
        "trusted source."
    )
    DOCS_MESSAGE = (
        "\n\nCheck the documentation of torch.load to learn more about types accepted by default with "
        "weights_only https://pytorch.org/docs/stable/generated/torch.load.html."
    )

    def _get_wo_message(message: str) -> str:
        unsafe_global_pattern = r"GLOBAL (\S+) was not an allowed global by default."
        has_unsafe_global = re.search(unsafe_global_pattern, message) is not None
        blocklist_pattern = r"whose module (\S+) is blocked"
        has_blocklist = re.search(blocklist_pattern, message) is not None
        if has_unsafe_global:
            updated_message = (
                "Weights only load failed. This file can still be loaded, to do so you have two options, "
                "\033[1mdo those steps only if you trust the source of the checkpoint\033[0m. "
                f"\n\t(1) {UNSAFE_MESSAGE}\n\t(2) Alternatively, to load with `weights_only=True` please check "
                "the recommended steps in the following error message.\n\tWeightsUnpickler error: "
                + message
            )
        else:
            updated_message = f"Weights only load failed. {UNSAFE_MESSAGE}\n"
            if not has_blocklist:
                updated_message += (
                    "Please file an issue with the following so that we can make "
                    "`weights_only=True` compatible with your use case: WeightsUnpickler error: "
                )
            updated_message += message
        return updated_message + DOCS_MESSAGE

    global _serialization_tls
    skip_data = _serialization_tls.skip_data
    if skip_data:
        raise RuntimeError(
            "`torch.load` called within a torch.serialization.skip_data context manager "
            "is not supported yet. Please call torch.load outside the skip_data context manager."
        )

    if weights_only is None:
        weights_only, warn_weights_only = False, True
    else:
        warn_weights_only = False

    # Add ability to force safe only weight loads via environment variable
    if os.getenv("TORCH_FORCE_WEIGHTS_ONLY_LOAD", "0").lower() in [
        "1",
        "y",
        "yes",
        "true",
    ]:
        weights_only = True

    if weights_only:
        if pickle_module is not None:
            raise RuntimeError(
                "Can not safely load weights when explicit pickle_module is specified"
            )
    else:
        if pickle_module is None:
            if warn_weights_only:
                warnings.warn(
                    "You are using `torch.load` with `weights_only=False` (the current default value), which uses "
                    "the default pickle module implicitly. It is possible to construct malicious pickle data "
                    "which will execute arbitrary code during unpickling (See "
                    "https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). "
                    "In a future release, the default value for `weights_only` will be flipped to `True`. This "
                    "limits the functions that could be executed during unpickling. Arbitrary objects will no "
                    "longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the "
                    "user via `torch.serialization.add_safe_globals`. We recommend you start setting "
                    "`weights_only=True` for any use case where you don't have full control of the loaded file. "
                    "Please open an issue on GitHub for any issues related to this experimental feature.",
                    FutureWarning,
                    stacklevel=2,
                )
            pickle_module = pickle

    # make flipping default BC-compatible
    if mmap is None:
        mmap = False

    _check_dill_version(pickle_module)

    if "encoding" not in pickle_load_args.keys():
        pickle_load_args["encoding"] = "utf-8"

    with _open_file_like(f, "rb") as opened_file:
        if _is_zipfile(opened_file):
            # The zipfile reader is going to advance the current file position.
            # If we want to actually tail call to torch.jit.load, we need to
            # reset back to the original position.
            orig_position = opened_file.tell()
            overall_storage = None
            with _open_zipfile_reader(opened_file) as opened_zipfile:
                if _is_torchscript_zip(opened_zipfile):
                    warnings.warn(
                        "'torch.load' received a zip file that looks like a TorchScript archive"
                        " dispatching to 'torch.jit.load' (call 'torch.jit.load' directly to"
                        " silence this warning)",
                        UserWarning,
                    )
                    opened_file.seek(orig_position)
                    return torch.jit.load(opened_file, map_location=map_location)
                if mmap:
                    if not _is_path(f):
                        raise ValueError(
                            "f must be a file path in order to use the mmap argument"
                        )
                    size = os.path.getsize(f)
                    if not IS_WINDOWS:
                        shared = get_default_mmap_options() == MAP_SHARED
                    else:
                        shared = False
                    overall_storage = torch.UntypedStorage.from_file(
                        os.fspath(f), shared, size
                    )
                if weights_only:
                    try:
                        return _load(
                            opened_zipfile,
                            map_location,
                            _weights_only_unpickler,
                            overall_storage=overall_storage,
                            **pickle_load_args,
                        )
                    except pickle.UnpicklingError as e:
                        raise pickle.UnpicklingError(_get_wo_message(str(e))) from None
                return _load(
                    opened_zipfile,
                    map_location,
                    pickle_module,
                    overall_storage=overall_storage,
                    **pickle_load_args,
                )
        if mmap:
            f_name = "" if not isinstance(f, str) else f"{f}, "
            raise RuntimeError(
                "mmap can only be used with files saved with "
                f"`torch.save({f_name}_use_new_zipfile_serialization=True), "
                "please torch.save your checkpoint with this option in order to use mmap."
            )
        if weights_only:
            try:
                return _legacy_load(
                    opened_file,
                    map_location,
                    _weights_only_unpickler,
                    **pickle_load_args,
                )
            except pickle.UnpicklingError as e:
                raise pickle.UnpicklingError(_get_wo_message(str(e))) from None
        return _legacy_load(
            opened_file, map_location, pickle_module, **pickle_load_args
        )
```

- torch `2.6`
```python
def load(
    f: FILE_LIKE,
    map_location: MAP_LOCATION = None,
    pickle_module: Any = None,
    *,
    weights_only: Optional[bool] = None,
    mmap: Optional[bool] = None,
    **pickle_load_args: Any,
) -> Any:
    # Reference: https://github.com/pytorch/pytorch/issues/54354
    # The first line of this docstring overrides the one Sphinx generates for the
    # documentation. We need it so that Sphinx doesn't leak `pickle`s path from
    # the build environment (e.g. `<module 'pickle' from '/leaked/path').

    """load(f, map_location=None, pickle_module=pickle, *, weights_only=True, mmap=None, **pickle_load_args)

    Loads an object saved with :func:`torch.save` from a file.

    :func:`torch.load` uses Python's unpickling facilities but treats storages,
    which underlie tensors, specially. They are first deserialized on the
    CPU and are then moved to the device they were saved from. If this fails
    (e.g. because the run time system doesn't have certain devices), an exception
    is raised. However, storages can be dynamically remapped to an alternative
    set of devices using the :attr:`map_location` argument.

    If :attr:`map_location` is a callable, it will be called once for each serialized
    storage with two arguments: storage and location. The storage argument
    will be the initial deserialization of the storage, residing on the CPU.
    Each serialized storage has a location tag associated with it which
    identifies the device it was saved from, and this tag is the second
    argument passed to :attr:`map_location`. The builtin location tags are ``'cpu'``
    for CPU tensors and ``'cuda:device_id'`` (e.g. ``'cuda:2'``) for CUDA tensors.
    :attr:`map_location` should return either ``None`` or a storage. If
    :attr:`map_location` returns a storage, it will be used as the final deserialized
    object, already moved to the right device. Otherwise, :func:`torch.load` will
    fall back to the default behavior, as if :attr:`map_location` wasn't specified.

    If :attr:`map_location` is a :class:`torch.device` object or a string containing
    a device tag, it indicates the location where all tensors should be loaded.

    Otherwise, if :attr:`map_location` is a dict, it will be used to remap location tags
    appearing in the file (keys), to ones that specify where to put the
    storages (values).

    User extensions can register their own location tags and tagging and
    deserialization methods using :func:`torch.serialization.register_package`.

    Args:
        f: a file-like object (has to implement :meth:`read`, :meth:`readline`, :meth:`tell`, and :meth:`seek`),
            or a string or os.PathLike object containing a file name
        map_location: a function, :class:`torch.device`, string or a dict specifying how to remap storage
            locations
        pickle_module: module used for unpickling metadata and objects (has to
            match the :attr:`pickle_module` used to serialize file)
        weights_only: Indicates whether unpickler should be restricted to
            loading only tensors, primitive types, dictionaries
            and any types added via :func:`torch.serialization.add_safe_globals`.
            See :ref:`weights-only` for more details.
        mmap: Indicates whether the file should be mmaped rather than loading all the storages into memory.
            Typically, tensor storages in the file will first be moved from disk to CPU memory, after which they
            are moved to the location that they were tagged with when saving, or specified by ``map_location``. This
            second step is a no-op if the final location is CPU. When the ``mmap`` flag is set, instead of copying the
            tensor storages from disk to CPU memory in the first step, ``f`` is mmaped.
        pickle_load_args: (Python 3 only) optional keyword arguments passed over to
            :func:`pickle_module.load` and :func:`pickle_module.Unpickler`, e.g.,
            :attr:`errors=...`.

    .. warning::
        :func:`torch.load()` unless `weights_only` parameter is set to `True`,
        uses ``pickle`` module implicitly, which is known to be insecure.
        It is possible to construct malicious pickle data which will execute arbitrary code
        during unpickling. Never load data that could have come from an untrusted
        source in an unsafe mode, or that could have been tampered with. **Only load data you trust**.

    .. note::
        When you call :func:`torch.load()` on a file which contains GPU tensors, those tensors
        will be loaded to GPU by default. You can call ``torch.load(.., map_location='cpu')``
        and then :meth:`load_state_dict` to avoid GPU RAM surge when loading a model checkpoint.

    .. note::
        By default, we decode byte strings as ``utf-8``.  This is to avoid a common error
        case ``UnicodeDecodeError: 'ascii' codec can't decode byte 0x...``
        when loading files saved by Python 2 in Python 3.  If this default
        is incorrect, you may use an extra :attr:`encoding` keyword argument to specify how
        these objects should be loaded, e.g., :attr:`encoding='latin1'` decodes them
        to strings using ``latin1`` encoding, and :attr:`encoding='bytes'` keeps them
        as byte arrays which can be decoded later with ``byte_array.decode(...)``.

    Example:
        >>> # xdoctest: +SKIP("undefined filepaths")
        >>> torch.load("tensors.pt", weights_only=True)
        # Load all tensors onto the CPU
        >>> torch.load("tensors.pt", map_location=torch.device("cpu"), weights_only=True)
        # Load all tensors onto the CPU, using a function
        >>> torch.load(
        ...     "tensors.pt", map_location=lambda storage, loc: storage, weights_only=True
        ... )
        # Load all tensors onto GPU 1
        >>> torch.load(
        ...     "tensors.pt",
        ...     map_location=lambda storage, loc: storage.cuda(1),
        ...     weights_only=True,
        ... )  # type: ignore[attr-defined]
        # Map tensors from GPU 1 to GPU 0
        >>> torch.load("tensors.pt", map_location={"cuda:1": "cuda:0"}, weights_only=True)
        # Load tensor from io.BytesIO object
        # Loading from a buffer setting weights_only=False, warning this can be unsafe
        >>> with open("tensor.pt", "rb") as f:
        ...     buffer = io.BytesIO(f.read())
        >>> torch.load(buffer, weights_only=False)
        # Load a module with 'ascii' encoding for unpickling
        # Loading from a module setting weights_only=False, warning this can be unsafe
        >>> torch.load("module.pt", encoding="ascii", weights_only=False)
    """
    torch._C._log_api_usage_once("torch.load")
    DOCS_MESSAGE = (
        "\n\nCheck the documentation of torch.load to learn more about types accepted by default with "
        "weights_only https://pytorch.org/docs/stable/generated/torch.load.html."
    )

    def _get_wo_message(message: str) -> str:
        unsafe_global_pattern = r"GLOBAL (\S+) was not an allowed global by default."
        has_unsafe_global = re.search(unsafe_global_pattern, message) is not None
        blocklist_pattern = r"whose module (\S+) is blocked"
        has_blocklist = re.search(blocklist_pattern, message) is not None
        import_pattern = r"(\S+) must be (\S+) to load"
        has_import = re.search(import_pattern, message) is not None
        if has_unsafe_global:
            updated_message = (
                "Weights only load failed. This file can still be loaded, to do so you have two options, "
                "\033[1mdo those steps only if you trust the source of the checkpoint\033[0m. "
                f"\n\t(1) {UNSAFE_MESSAGE}\n\t(2) Alternatively, to load with `weights_only=True` please check "
                "the recommended steps in the following error message.\n\tWeightsUnpickler error: "
                + message
            )
        else:
            if has_import:
                return f"Weights only load failed. {message}\n {UNSAFE_MESSAGE}\n"
            else:
                updated_message = f"Weights only load failed. {UNSAFE_MESSAGE}\n"
                if not has_blocklist:
                    updated_message += (
                        "Please file an issue with the following so that we can make "
                        "`weights_only=True` compatible with your use case: WeightsUnpickler error: "
                    )
            updated_message += message
        return updated_message + DOCS_MESSAGE

    global _serialization_tls
    skip_data = _serialization_tls.skip_data
    if skip_data:
        raise RuntimeError(
            "`torch.load` called within a torch.serialization.skip_data context manager "
            "is not supported yet. Please call torch.load outside the skip_data context manager."
        )

    weights_only_not_set = weights_only is None

    if weights_only_not_set:
        weights_only = _default_to_weights_only(pickle_module)

    true_values = ["1", "y", "yes", "true"]
    # Add ability to force safe only or non-safe weight loads via environment variables
    force_weights_only_load = (
        os.getenv("TORCH_FORCE_WEIGHTS_ONLY_LOAD", "0") in true_values
    )
    force_no_weights_only_load = (
        os.getenv("TORCH_FORCE_NO_WEIGHTS_ONLY_LOAD", "0") in true_values
    )

    if force_weights_only_load and force_no_weights_only_load:
        raise RuntimeError(
            "Only one of `TORCH_FORCE_WEIGHTS_ONLY_LOAD` or `TORCH_FORCE_NO_WEIGHTS_ONLY_LOAD` "
            "should be set, but both were set."
        )
    elif force_weights_only_load:
        weights_only = True
    elif force_no_weights_only_load:
        # TORCH_FORCE_NO_WEIGHTS_ONLY_LOAD can only override if callsite did not explicitly set weights_only
        if weights_only_not_set:
            warnings.warn(
                "Environment variable TORCH_FORCE_NO_WEIGHTS_ONLY_LOAD detected, since the"
                "`weights_only` argument was not explicitly passed to `torch.load`, forcing weights_only=False.",
                UserWarning,
                stacklevel=2,
            )
            weights_only = False

    if weights_only:
        if pickle_module is not None:
            raise RuntimeError(
                "Can not safely load weights when explicit pickle_module is specified"
            )
    else:
        if pickle_module is None:
            pickle_module = pickle

    # make flipping default BC-compatible
    if mmap is None:
        mmap = False

    _check_dill_version(pickle_module)

    if "encoding" not in pickle_load_args.keys():
        pickle_load_args["encoding"] = "utf-8"

    with _open_file_like(f, "rb") as opened_file:
        if _is_zipfile(opened_file):
            # The zipfile reader is going to advance the current file position.
            # If we want to actually tail call to torch.jit.load, we need to
            # reset back to the original position.
            orig_position = opened_file.tell()
            overall_storage = None
            with _open_zipfile_reader(opened_file) as opened_zipfile:
                if _is_torchscript_zip(opened_zipfile):
                    warnings.warn(
                        "'torch.load' received a zip file that looks like a TorchScript archive"
                        " dispatching to 'torch.jit.load' (call 'torch.jit.load' directly to"
                        " silence this warning)",
                        UserWarning,
                    )
                    if weights_only:
                        raise RuntimeError(
                            "Cannot use ``weights_only=True`` with TorchScript archives passed to "
                            "``torch.load``. " + UNSAFE_MESSAGE
                        )
                    opened_file.seek(orig_position)
                    return torch.jit.load(opened_file, map_location=map_location)
                if mmap:
                    if not _is_path(f):
                        raise ValueError(
                            "f must be a file path in order to use the mmap argument"
                        )
                    size = os.path.getsize(f)
                    if not IS_WINDOWS:
                        shared = get_default_mmap_options() == MAP_SHARED
                    else:
                        shared = False
                    overall_storage = torch.UntypedStorage.from_file(
                        os.fspath(f), shared, size
                    )
                if weights_only:
                    try:
                        return _load(
                            opened_zipfile,
                            map_location,
                            _weights_only_unpickler,
                            overall_storage=overall_storage,
                            **pickle_load_args,
                        )
                    except pickle.UnpicklingError as e:
                        raise pickle.UnpicklingError(_get_wo_message(str(e))) from None
                return _load(
                    opened_zipfile,
                    map_location,
                    pickle_module,
                    overall_storage=overall_storage,
                    **pickle_load_args,
                )
        if mmap:
            f_name = "" if not isinstance(f, str) else f"{f}, "
            raise RuntimeError(
                "mmap can only be used with files saved with "
                f"`torch.save({f_name}_use_new_zipfile_serialization=True), "
                "please torch.save your checkpoint with this option in order to use mmap."
            )
        if weights_only:
            try:
                return _legacy_load(
                    opened_file,
                    map_location,
                    _weights_only_unpickler,
                    **pickle_load_args,
                )
            except pickle.UnpicklingError as e:
                raise pickle.UnpicklingError(_get_wo_message(str(e))) from None
        return _legacy_load(
            opened_file, map_location, pickle_module, **pickle_load_args
        )
```

# Error: CUDA Out of Memory (OOM)

## Common OOM Error
- `torch.OutOfMemoryError: CUDA out of memory. Tried to allocate 20.00 MiB. GPU 0 has a total capacity of 79.25 GiB of which 17.19 MiB is free. Process 1026994 has 73.21 GiB memory in use. Process 488075 has 6.01 GiB memory in use. Of the allocated memory 5.60 GiB is allocated by PyTorch, and 9.08 MiB is reserved by PyTorch but unallocated.`

## Solutions to Reduce Memory Usage

### 1. Enable Gradient Checkpointing
Gradient checkpointing trades computation for memory by recomputing activations during backward pass:
```yaml
actor:
  model:
    gradient_checkpointing: True  # Change from False to True
```

### 2. Reduce Sequence Length
Large sequence lengths consume significant memory:
```yaml
runner:
  seq_length: 2048  # Reduce from 4096 to 2048 (or even 1024)
```

### 3. Reduce Batch Sizes
Reduce micro batch size and global batch size:
```yaml
actor:
  micro_batch_size: 20  # Reduce from 40
  global_batch_size: 320  # Reduce from 640 (keep ratio)
```

### 4. Use the Mini Config
The `maniskill_ppo_openvla_mini.yaml` config has memory-optimized settings:
```bash
bash examples/embodiment/run_embodiment.sh maniskill_ppo_openvla_mini
```

### 5. Enable FSDP Parameter Offloading
Offload model parameters to CPU when not in use:
```yaml
actor:
  fsdp_config:
    param_offload: True  # Offload parameters to CPU
    optimizer_offload: True  # Offload optimizer states to CPU
```

### 6. Separate Component Placement
If you have more GPUs, separate components to different GPUs:
```yaml
cluster:
  component_placement:
    actor: "0-1"      # Actor on GPUs 0-1
    env: "2-3"        # Environment on GPUs 2-3
    rollout: "4-5"    # Rollout on GPUs 4-5
```

### 7. Reduce Number of Environments
Fewer parallel environments = less memory:
```yaml
algorithm:
  num_group_envs: 64  # Reduce from 128
```

### 8. Check for Memory Leaks
- Ensure `enable_offload: True` is set for all components (env, rollout, actor)
- Monitor GPU memory with `nvidia-smi` during training
- Kill any zombie processes holding GPU memory

### 9. Environment Variable
Already set in `run_embodiment.sh`:
```bash
export PYTORCH_CUDA_ALLOC_CONF=expandable_segments:False
```

## Quick Fix: Use Mini Config
The fastest solution is to use the pre-configured mini version:
```bash
bash examples/embodiment/run_embodiment.sh maniskill_ppo_openvla_mini
```

This config has:
- `seq_length: 2048` (instead of 4096)
- Other memory optimizations
